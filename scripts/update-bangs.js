#!/usr/bin/env node

import fs from "node:fs";
import https from "node:https";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// const BANG_URL = "https://duckduckgo.com/bang.js";
const BANG_URL = "https://raw.githubusercontent.com/kagisearch/bangs/refs/heads/main/data/bangs.json";
const BANG_FILE_PATH = path.join(__dirname, "..", "src", "bang.ts");

/**
 * Fetch data from Kagi
 */
function fetchBangData() {
  return new Promise((resolve, reject) => {
    console.log("Fetching bang data from Kagi...");

    https
      .get(BANG_URL, (res) => {
        let data = "";

        res.on("data", (chunk) => {
          data += chunk;
        });

        res.on("end", () => {
          try {
            // Parse the JSON array from the response
            const bangData = JSON.parse(data);
            console.log(`Fetched ${bangData.length} bangs from Kagi`);
            resolve(bangData);
          } catch (error) {
            reject(new Error(`Failed to parse JSON: ${error.message}`));
          }
        });
      })
      .on("error", (error) => {
        reject(new Error(`HTTP request failed: ${error.message}`));
      });
  });
}

/**
 * Convert Kagi bang format to our format
 * Kagi format: {"c":"Tech","d":"www.01net.com","r":0,"s":"01net","sc":"Downloads (apps)","t":"01net","u":"http://..."}
 * Our format: {t: "01net", s: "01net", u: "http://...", d: "www.01net.com"}
 */
function convertBangFormat(bangs) {
  console.log("Converting bang format...");

  return bangs.map((bang) => ({
    t: bang.t, // trigger
    s: bang.s, // name/description
    u: bang.u, // url template
    d: bang.d, // domain
  }));
}

/**
 * Generate the TypeScript file content
 */
function generateBangFileContent(bangs) {
  console.log("Generating TypeScript file content...");

  const bangEntries = bangs
    .map((bang) => {
      // Escape quotes and backslashes in strings
      const escapedT = bang.t.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      const escapedS = bang.s.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      const escapedU = bang.u.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      const escapedD = bang.d.replace(/\\/g, "\\\\").replace(/"/g, '\\"');

      return `  {
    t: "${escapedT}",
    s: "${escapedS}",
    u: "${escapedU}",
    d: "${escapedD}"
  }`;
    })
    .join(",\n");

  return `// This file is auto-generated by scripts/update-bangs.js
// Do not edit manually - changes will be overwritten
// Last updated: ${new Date().toISOString()}

export const bangs = [
${bangEntries}
];
`;
}

/**
 * Write the updated bang file
 */
function writeBangFile(content) {
  console.log(`Writing updated bang file to ${BANG_FILE_PATH}...`);

  try {
    fs.writeFileSync(BANG_FILE_PATH, content, "utf8");
    console.log("Bang file updated successfully!");
  } catch (error) {
    throw new Error(`Failed to write bang file: ${error.message}`);
  }
}

/**
 * Main function
 */
async function main() {
  try {
    console.log("Starting bang list update...");

    // Fetch data from Kagi
    const bangs = await fetchBangData();

    // Convert to our format
    const convertedBangs = convertBangFormat(bangs);

    // Generate file content
    const fileContent = generateBangFileContent(convertedBangs);

    // Write to file
    writeBangFile(fileContent);

    console.log(`✅ Successfully updated bang list with ${convertedBangs.length} entries`);
  } catch (error) {
    console.error("❌ Error updating bang list:", error.message);
    process.exit(1);
  }
}

// Run the script
main();
